classify <- ifelse(dat_preds > cutoff, 1, 0)
percent_misclass[i] <- mean(classify != dat_binary)}
misclass_data <- as.data.frame(cbind(percent_misclass, possible_cutoffs))
cutoff <- possible_cutoffs[which.min(percent_misclass)]
cutoff
# your code here
dat_preds <- predict.glm(model_glm_int, type = "response")
possible_cutoffs <- seq(0, 1, length = 100)
dat_binary <- dat$Survived
percent_misclass <- rep(NA, length(possible_cutoffs))
for(i in 1:length(possible_cutoffs)) {
cutoff <- possible_cutoffs[i]
classify <- ifelse(dat_preds > cutoff, 1, 0)
percent_misclass[i] <- mean(classify != dat_binary)}
misclass_data <- as.data.frame(cbind(percent_misclass, possible_cutoffs))
cutoff <- possible_cutoffs[which.min(percent_misclass)]
cutoff
ggplot(data = misclass_data) +
geom_line(mapping = aes(x = possible_cutoffs, y = percent_misclass),
size = 2) +
theme_bw() +
xlab("Cutoff Value") +
ylab("Percent Misclassified") +
theme(aspect.ratio = 1)
dat_1_logistic <- glm(Survived ~ Pclass + Age + SibSp,
data = dat,
family = binomial(link = "logit"))
summary(dat_1_logistic)
dat_1_logistic <- glm(Survived ~ Pclass + Age + SibSp,
data = dat,
family = binomial(link = "logit"))
summary(dat_1_logistic)
age_coef <- (summary(dat_1_logistic))$coefficients[3]
age_coef
exp(age_coef)
100 * (exp(age_coef) - 1)
dat_1_logistic <- glm(Survived ~ Pclass + Age + SibSp,
data = dat,
family = binomial(link = "logit"))
summary(dat_1_logistic)
age_coef <- (summary(dat_1_logistic))$coefficients[4]
age_coef
exp(age_coef)
100 * (exp(age_coef) - 1)
# your code here
100 *(exp(-0.0341)-1)
# load packages here
library(bestglm)
dat_vifs <- vif(dat_logistic)
dat_vifs
mean(dat_vifs)
# load packages here
library(bestglm)
library(car)
dat_vifs <- vif(dat_logistic)
dat_vifs
# load packages here
library(bestglm)
library(car)
library(ggplot)
# load packages here
library(bestglm)
library(car)
library(tidyverse)
library(pROC)  # for the ROC curve
library(ROCR)
#Normality Assumption
new_elec_lm_trans_qq <- autoplot(new_elec_lm_trans, which = 2, ncol = 1, nrow = 1)+
theme(aspect.ratio = 1)
library(tidyverse)
library(lubridate)
library(corrplot)
library(bestglm)
library(lmtest)
library(ggplot2)
library(car)
elec <- read.csv("IrishElectricity.csv")
summary(elec)
elec <- as.data.frame(elec)
elec$Date <- mdy(elec$Date)
elec$Year <- year(elec$Date)
elec$Year <- as.factor(elec$Year)
elec$Day <- as.factor(elec$Day)
summary(elec)
ggplot(data = elec) +
geom_point(mapping = aes(x = Energy,
y = MinTemp,
color = Year)) +
theme(aspect.ratio = 1)
ggplot(data = elec) +
geom_point(mapping = aes(x = MinTemp,
y = Energy,
color = Year)) +
theme(aspect.ratio = 1)
ggplot(data = elec) +
geom_point(mapping = aes(x = Year,
y = MinTemp,
color = Year)) +
theme(aspect.ratio = 1)
elec2 <- elec %>%
mutate(year = format(Date, format = "%Y")) %>%
mutate(year = as.factor(year)) %>%
mutate_if(is.character, as.factor)
summary(elec2)
elec2010 <- elec2 %>%
filter(year == 2010) %>%
select(-year)
elec2009 <- elec2 %>%
filter(year == 2009) %>%
select(-year)
head(elec2009)
ggplot(data = elec2) +
geom_boxplot(mapping = aes(x = MinTemp, y = Energy)) +
theme(aspect.ratio = 1)
# Linear Model
lm_elec <- lm(Energy~MinTemp + Year, data = elec)
summary(lm_elec)
#lm_elec2_2009 <- lm(Energy~MinTemp, data = elec2009)
#summary(lm_elec2_2009)
ggplot(elec) +
geom_point(mapping = aes(x = MinTemp,
y = Energy,
color = Year),) +
geom_line(mapping = aes(x = MinTemp,
y = predict(lm_elec),
color = Year)) +
theme(aspect.ratio = 1)
ggplot(data = elec, aes(x = Year, y= Energy)) +
geom_boxplot() +
labs(title ="Energy vs Year", x = "Year", y = "Energy") +
theme(plot.title = element_text(hjust = 0.5))
ggplot(data = elec2009) +
geom_boxplot(mapping = aes(x = MinTemp, y = Energy)) +
theme(aspect.ratio = 1)
ggplot(data = elec2010) +
geom_boxplot(mapping = aes(x = MinTemp, y = Energy)) +
theme(aspect.ratio = 1)
elec2$num_days <- as.numeric(elec2$Date) - 14562
elec2 <- elec %>% relocate(Energy,.after = last_col())
best_elec2_bic <- bestglm(elec2[-1],
IC = "BIC",
method = "exhaustive",
TopModels = 10)
summary(best_elec2_bic$BestModel)
new_elec <- elec[c(-40,-41,-42,-48),]
new_elec
lm_new_elec <- lm(Energy~MinTemp + Year, data = new_elec)
summary(lm_new_elec)
lm_new_elec$residuals <- lm_new_elec$residuals
ggplot(new_elec) +
geom_point(mapping = aes(x = MinTemp,
y = Energy,
color = Year),) +
geom_line(mapping = aes(x = MinTemp,
y = predict(lm_new_elec),
color = Year)) +
theme(aspect.ratio = 1)
elec$cooksd <- cooks.distance(lm_elec)
ggplot(data = elec) +
geom_point(mapping = aes(x = as.numeric(rownames(elec)),
y = cooksd)) +
ylab("Cook's Distance") +
xlab("Observation Number") +
geom_hline(mapping = aes(yintercept = 4 / length(cooksd)),
color = "red",
linetype = "dashed") +
theme(aspect.ratio = 1)
elec %>%
mutate(rowNum = row.names(elec)) %>%  # save original row numbers
filter(cooksd > 4 / length(cooksd)) %>%  # select potential outliers
arrange(desc(cooksd))
new_elec$cooksd <- cooks.distance(lm_new_elec)
ggplot(data = new_elec) +
geom_point(mapping = aes(x = as.numeric(rownames(new_elec)),
y = cooksd)) +
ylab("Cook's Distance") +
xlab("Observation Number") +
geom_hline(mapping = aes(yintercept = 4 / length(cooksd)),
color = "red",
linetype = "dashed") +
theme(aspect.ratio = 1)
new_elec %>%
mutate(rowNum = row.names(new_elec)) %>%  # save original row numbers
filter(cooksd > 4 / length(cooksd)) %>%  # select potential outliers
arrange(desc(cooksd))
new_elec %>%
mutate(rowNum = row.names(new_elec)) %>%  # save original row numbers
filter(cooksd > 4 / length(cooksd)) %>%  # select potential outliers
arrange(desc(cooksd))
bc <- boxCox(lm_new_elec)  # plot curve
bc$x[which.max(bc$y)]
shapiro.test(lm_new_elec$residuals)
ggplot(data = new_elec) +
geom_histogram(mapping = aes(x = lm_new_elec$residuals, y = ..density..),
binwidth = .5) +
stat_function(fun = dnorm,
color = "chartreuse",
size = 2,
args = list(mean = mean(lm_new_elec$residuals),
sd = sd(lm_new_elec$residuals))) +
theme(aspect.ratio = 1)
ggplot(new_elec) +
geom_point(mapping = aes(x = MinTemp,
y = Energy,
color = Year),) +
geom_line(mapping = aes(x = MinTemp,
y = predict(lm_new_elec),
color = Year)) +
theme(aspect.ratio = 1)
bptest(lm_new_elec)
new_elec_inter_lm <- lm(Energy ~ MinTemp + Year + MinTemp:Year, data = new_elec)
summary(new_elec_inter_lm)
new_elec$residuals_inter <- new_elec_inter_lm$residuals
new_elec$fitted_inter <- new_elec_inter_lm$fitted.values
new_elec_inter_lm_qq <- autoplot(new_elec_inter_lm, which = 2, ncol = 1, nrow = 1)+
theme(aspect.ratio = 1)
new_elec_inter_lm_qq
new_elec_inter_lm_resid_vs_fit <- autoplot(new_elec_inter_lm,
which = 1, ncol = 1, nrow = 1) +
theme(aspect.ratio = 1)
new_elec_inter_lm_resid_vs_fit
# Transformed LM
#new_elec$Energy_trans <- 1/((new_elec$Energy)**2)
new_elec_trans <- (new_elec$Energy^(-2)-1)/(-2)
new_elec_lm_trans <- lm(new_elec_trans ~ MinTemp + Year,
data = new_elec)
new_elec_lm_trans_inter <- lm(new_elec_trans ~ MinTemp + Year + MinTemp*Year,
data = new_elec)
summary(new_elec_lm_trans)
summary(new_elec_lm_trans_inter)
new_elec$residuals_trans <- new_elec_lm_trans$residuals
new_elec$fittedEnergy_trans <- new_elec_lm_trans$fitted.values
new_elec$residuals_trans_inter <- new_elec_lm_trans_inter$residuals
new_elec$fittedEnergy_trans_inter <- new_elec_lm_trans_inter$fitted.values
#Normality Assumption
new_elec_lm_trans_qq <- autoplot(new_elec_lm_trans, which = 2, ncol = 1, nrow = 1)+
theme(aspect.ratio = 1)
new_elec_lm_trans_qq
new_elec_lm_trans_inter_qq <- autoplot(new_elec_lm_trans_inter, which = 2, ncol = 1,
nrow = 1)+
theme(aspect.ratio = 1)
new_elec_lm_trans_inter_qq
new_elec_qq <- autoplot(lm_new_elec, which = 2, ncol = 1, nrow = 1)+
theme(aspect.ratio = 1)
new_elec_qq
#Scatterplot for Assessing Linearity
ggplot(new_elec) +
geom_point(mapping = aes(x = MinTemp,
y = new_elec_trans,
color = Year),) +
geom_line(mapping = aes(x = MinTemp,
y = predict(new_elec_lm_trans),
color = Year)) +
theme(aspect.ratio = 1)
ggplot(new_elec) +
geom_point(mapping = aes(x = MinTemp,
y = new_elec_trans,
color = Year),) +
geom_line(mapping = aes(x = MinTemp,
y = predict(new_elec_lm_trans_inter),
color = Year)) +
theme(aspect.ratio = 1)
ggplot(new_elec) +
geom_point(mapping = aes(x = MinTemp,
y = Energy,
color = Year),) +
geom_line(mapping = aes(x = MinTemp,
y = predict(lm_new_elec),
color = Year)) +
theme(aspect.ratio = 1)
# Residuals vs Fitted Values for Equal Variance Assumption
new_elec_lm_trans_inter_resid_vs_fit <- autoplot(new_elec_lm_trans_inter,
which = 1, ncol = 1, nrow = 1) +
theme(aspect.ratio = 1)
new_elec_lm_trans_inter_resid_vs_fit
lm_new_elec_resid_vs_fit <- autoplot(lm_new_elec, which = 1, ncol = 1, nrow = 1) +
theme(aspect.ratio = 1)
lm_new_elec_resid_vs_fit
# Histogram- Needs Help!
ggplot(data = new_elec) +
geom_histogram(mapping = aes(x = residuals_trans, y = ..density..),
binwidth = .000008) +
stat_function(fun = dnorm,
color = "chartreuse",
size = 2,
args = list(mean = mean(new_elec$residuals_trans),
sd = sd(new_elec$residuals_trans))) +
theme(aspect.ratio = 1)
ggplot(data = new_elec) +
geom_histogram(mapping = aes(x = lm_new_elec$residuals, y = ..density..),
binwidth = .5) +
stat_function(fun = dnorm,
color = "chartreuse",
size = 2,
args = list(mean = mean(lm_new_elec$residuals),
sd = sd(lm_new_elec$residuals))) +
theme(aspect.ratio = 1)
ggplot(data = new_elec) +
geom_histogram(mapping = aes(x = new_elec$residuals_trans_inter, y = ..density..),
binwidth = .00001) +
stat_function(fun = dnorm,
color = "lightblue1",
size = 2,
args = list(mean = mean(new_elec$residuals_trans_inter),
sd = sd(new_elec$residuals_trans_inter))) +
theme(aspect.ratio = 1)
# Shapiro-Wilk for Normality
shapiro.test(new_elec$residuals_trans)
shapiro.test(lm_new_elec$residuals)
shapiro.test(new_elec$residuals_trans_inter)
bptest(lm_new_elec)
ggplot(data = new_elec, aes(x = Year, y= Energy)) +
geom_boxplot() +
labs(title ="Energy vs Year", x = "Year", y = "Energy") +
theme(plot.title = element_text(hjust = 0.5))
ggplot(data = new_elec, aes(x = Year, y= new_elec_trans)) +
geom_boxplot() +
labs(title ="Energy vs Year", x = "Year", y = "Transformed Energy") +
theme(plot.title = element_text(hjust = 0.5))
# Checking Model Fit
AIC(lm_new_elec)
BIC(lm_new_elec)
AIC(new_elec_lm_trans_inter)
BIC(new_elec_lm_trans_inter)
AIC(new_elec_lm_trans)
BIC(new_elec_lm_trans)
bc <- boxCox(lm_new_elec)  # plot curve
bc$x[which.max(bc$y)]
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(corrplot)
library(bestglm)
library(lmtest)
library(ggplot2)
elec <- IrishElectricity
elec <- as.data.frame(elec)
elec$Date <- mdy(elec$Date)
elec$Year <- year(elec$Date)
elec$Year <- as.factor(elec$Year)
elec$Day <- as.factor(elec$Day)
summary(elec)
ggplot(data = elec) +
geom_boxplot(mapping = aes(x = Year, y = Energy)) +
theme(aspect.ratio = 1)
ggplot(data = elec) +
geom_point(mapping = aes(x = Energy,
y = MinTemp,
color = Year)) +
theme(aspect.ratio = 1)
ggplot(data = elec) +
geom_histogram(mapping = aes(x = Energy, y = after_stat(density)),
binwidth = 2) +
theme_bw() +
theme(aspect.ratio = 1)
elec$num_days <- as.numeric(elec$Date) - 14562
elec <- elec %>% relocate(Energy,.after = last_col())
best_elec_bic <- bestglm(elec[-1],
IC = "BIC",
method = "exhaustive",
TopModels = 10)
summary(best_elec_bic$BestModel)
elec_lm <- glm(Energy ~ MinTemp + Year,
data = elec)
summary(elec_lm)
elec$residuals <- elec_lm$residuals
elec$cooksd <- cooks.distance(best_elec_bic$BestModel)
ggplot(data = elec) +
geom_point(mapping = aes(x = as.numeric(rownames(elec)),
y = cooksd)) +
ylab("Cook's Distance") +
xlab("Observation Number") +
geom_hline(mapping = aes(yintercept = 4 / length(cooksd)),
color = "red",
linetype = "dashed") +
theme(aspect.ratio = 1)
ggplot(elec) +
geom_point(mapping = aes(x = MinTemp,
y = Energy,
color = Year),) +
geom_line(mapping = aes(x = MinTemp,
y = predict(best_elec_bic$BestModel),
color = Year)) +
theme(aspect.ratio = 1)
elec_boxplot <- ggplot(data = elec) +
geom_boxplot(mapping = aes(y = elec$residuals))+
theme(aspect.ratio = 1)
elec_boxplot
elec_qq <- autoplot(elec_lm, which = 2, ncol = 1, nrow = 1)+
theme(aspect.ratio = 1)
elec_qq
shapiro.test(elec_lm$residuals)
elec_resid_vs_fit <- autoplot(elec_lm, which = 1, ncol = 1, nrow = 1) +
theme(aspect.ratio = 1)
elec_resid_vs_fit
bptest(elec_lm)
elec$dfbetas_precip <- as.vector(dfbetas(elec_lm)[, 2])
ggplot(data = elec) +
geom_point(mapping = aes(x = as.numeric(rownames(elec)),
y = abs(dfbetas_precip))) +
ylab("Absolute Value of DFBETAS for Precipitation") +
xlab("Observation Number") +
geom_hline(mapping = aes(yintercept = 2 / sqrt(length(dfbetas_precip))),
color = "red",
linetype = "dashed") +
theme(aspect.ratio = 1)
elec_inter_lm <- glm(Energy ~ MinTemp + Year + MinTemp:Year,
data = elec)
summary(elec_inter_lm)
elec$inter_residuals <- elec_inter_lm$residuals
ggplot(elec) +
geom_point(mapping = aes(x = MinTemp,
y = Energy,
color = Year),) +
geom_line(mapping = aes(x = MinTemp,
y = predict(elec_inter_lm),
color = Year)) +
theme(aspect.ratio = 1)
ggplot(elec) +
geom_point(mapping = aes(x = MinTemp,
y = Energy,
color = Year),) +
geom_line(mapping = aes(x = MinTemp,
y = predict(best_elec_bic$BestModel),
color = Year)) +
theme(aspect.ratio = 1)
bike_train <- vroom("./train.csv") %>%
select(-c("casual", "registered"))
bike_test <-vroom("./test.csv")
install.packages("tidymodels")
library(vroom)
bike_train <- vroom("./train.csv") %>%
select(-c("casual", "registered"))
library(tidymodels)
library(tidyverse)
library(dplyr)
bike_train <- vroom("./train.csv") %>%
select(-c("casual", "registered"))
setwd("/Users/lucydornon/Documents/Stat 348/KaggleBikeShare")
bike_train <- vroom("./train.csv") %>%
select(-c("casual", "registered"))
bike_test <-vroom("./test.csv")
myRecipe <- recipe(count~., data = bike_train) %>%
step_mutate(weather = ifelse(weather==4, 3,weather)) %>%
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>%
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>%
step_mutate(workingday=factor(workingday,levels=c(0,1), labels=c("No", "Yes"))) %>%
step_time(datetime, features="hour")
prepped_recipe<- prep(myRecipe)
bake(prepped_recipe, bike_train)
bake(prepped_recipe, new_data = bike_test)
my_mod <- linear_reg() %>%
set_engine("lm")
bike_workflow <- workflow() %>%
add_recipe(myRecipe) %>%
add_model(my_mod) %>%
fit(data = bike_train)
extract_fit_engine(bike_workflow) %>%
summary()
test_preds <- predict(bike_workflow, new_data = bike_test) %>%
bind_cols(., bike_test) %>% #Bind predictions with test data
select(datetime, .pred) %>% #Just keep datetime and predictions
rename(count=.pred) %>% #rename pred to count (for submission to Kaggle)
mutate(count=pmax(0, count)) %>% #pointwise max of (0, prediction)
mutate(datetime=as.character(format(datetime))) #needed for right format to Kaggle
library(poissonreg)
pois_mod <- poisson_reg() %>%
set_engine("glm")
bike_pois_workflow <- workflow() %>%
add_recipe(myRecipe) %>%
add_model(pois_mod) %>%
fit(data = bike_train)
bike_predictions <- predict(bike_pois_workflow,new_data = bike_test) %>%
bind_cols(., bike_test) %>%
select(datetime, .pred) %>%
rename(count=.pred) %>%
mutate(count=pmax(0, count)) %>%
mutate(datetime=as.character(format(datetime)))
myRecipe <- recipe(count~., data = bike_train) %>%
step_mutate(weather = ifelse(weather==4, 3,weather)) %>%
step_mutate(weather=factor(weather, levels=1:3, labels=c("Sunny", "Mist", "Rain"))) %>%
step_mutate(holiday=factor(holiday, levels=c(0,1), labels=c("No", "Yes"))) %>%
step_mutate(workingday=factor(workingday,levels=c(0,1), labels=c("No", "Yes"))) %>%
step_time(datetime, features="hour") %>%
step_dummy(all_nominal_predictors()) %>%
step_normalize(all_numeric_predictors()) %>%
step_rm(datetime)
preg_model <- linear_reg(penalty=0, mixture=0 ) %>%
set_engine("glmnet")
preg_wf <- workflow() %>%
add_recipe(myRecipe) %>%
add_model(preg_model) %>%
fit(data = bike_train)
Penalized_regression <-predict(preg_wf, new_data = bike_test) %>%
bind_cols(., bike_test) %>%
select(datetime, .pred) %>%
rename(count=.pred) %>%
mutate(count=pmax(0, count)) %>%
mutate(datetime=as.character(format(datetime)))
log_bike_train <- log(bike_train)
extract_fit_engine(bike_workflow) %>%
summary()
library(tidymodels)
library(poissonreg)
source("~/Documents/Stat 348/KaggleBikeShare/BikeShareAnalysis.R", echo=TRUE)
CV_results <- preg_wf %>%
preg_model <- linear_reg(penalty=tune(),
mixture = tune()) %>%
set_engine("glmnet")
preg_model <- linear_reg(penalty=tune(),
mixture = tune()) %>%
set_engine("glmnet")
